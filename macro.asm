.MACRO OUTU
			PUSH 	R16
			LDI 	R16,@0 		
uart_wt:	SBIS 	UCSRA,UDRE	; Пропуск если нет флага готовности
			RJMP	uart_wt 	; ждем готовности - флага UDRE0
 			OUT		UDR, R16	; шлем байт!
			POP 	R16
.ENDM  
//***********************************************************************
.MACRO OUTUR
uart_wt:	SBIS 	UCSRA,UDRE	; Пропуск если нет флага готовности
			RJMP	uart_wt 	; ждем готовности - флага UDRE0
 			OUT		UDR, @0	; шлем байт!
.ENDM  
//*********************************************************************** 
.MACRO DDLOOP       ; МАКРОС ЗАДЕРЖКИ x3
 		PUSH	R16	; Сохранили R16
		PUSH	R17	; Сохранили R17
		PUSH	R19	; Сохранили R19

		;==================== цикл задержки ============
		LDI	R16,@0	; Число итераций, аргумент 1
DLoop3: LDI	R17,@1	; Число под итераций, аргумент 2
DLoop2: LDI	R19,@2	; Число итераций, аргумент 3
		;==================== цикл задержки ============
DLoop1: DEC	R19		; Уменьшаем R17 на 1.
		BRNE	DLoop1	; Если декремент не вызвал обнуление R19
	    ;==================== цикл задержки ============
		DEC	R17	; Уменьшаем R16 на 1.
		BRNE	DLoop2	; Если декремент не вызвал обнуление R17
	    ;==================== цикл задержки ============
		DEC	R16	; Уменьшаем R16 на 1.
		BRNE	DLoop3	; Если декремент не вызвал обнуление R16

	    
		POP	R19		; Восстановили R17
		POP	R17		; Восстановили R17
		POP	R16		; Восстановили R16
.ENDM               ; End macro definition
//***********************************************************************
.MACRO DLOOP        ; МАКРОС ЗАДЕРЖКИ
 		PUSH	R16	; Сохранили R16
		PUSH	R17	; Сохранили R17
		;==================== цикл задержки ============
		LDI	R16,@0	; Число итераций, аргумент 1
Loop:	LDI	R17,@1	; Число под итераций, аргумент 2
Loop2:	DEC	R17		; Уменьшаем R17 на 1.
		BRNE	Loop2	; Если декремент не вызвал обнуление R18
	    ;==================== цикл задержки ============
		DEC	R16	; Уменьшаем R16 на 1.
		BRNE	Loop	; Если декремент не вызвал обнуление R17
	    ;==================== цикл задержки ============
		POP	R17		; Восстановили R17
		POP	R16		; Восстановили R16
.ENDM               ; End macro definition
//***********************************************************************

.MACRO DDRLOOP       ; МАКРОС ЗАДЕРЖКИ x3
 		PUSH	R16	; Сохранили R16
		PUSH	R17	; Сохранили R17
		PUSH	R19	; Сохранили R19

		;==================== цикл задержки ============
		CLR R16
	
		MOV	R16,@0	; Число итераций, аргумент из буфера уарта
DLoop3: LDI	R17,@1	; Число под итераций, аргумент 2
DLoop2: LDI	R19,@2	; Число итераций, аргумент 3
		;==================== цикл задержки ============
DLoop1: DEC	R19		; Уменьшаем R17 на 1.
		BRNE	DLoop1	; Если декремент не вызвал обнуление R19
	    ;==================== цикл задержки ============
		DEC	R17	; Уменьшаем R16 на 1.
		BRNE	DLoop2	; Если декремент не вызвал обнуление R17
	    ;==================== цикл задержки ============
		DEC	R16	; Уменьшаем R16 на 1.
		BRNE	DLoop3	; Если декремент не вызвал обнуление R16

	    
		POP	R19		; Восстановили R17
		POP	R17		; Восстановили R17
		POP	R16		; Восстановили R16
.ENDM               ; End macro definition

//***********************************************************************
.MACRO outi				; Это описание макроса. Везде где outi встретится в коде, то заменяется на 
			PUSH 	R16
			LDI 	R16,@1 			; этот кусок кода, причем @0,@1 это параметры, они заменятся введенными параметрами
			OUT 	@0,R16 			; макроса. Данный макрос тупо копирует введенное число сначала в регистр R16, а из него куда надо
			POP		R16
.ENDM
//***********************************************************************
//////////////////////////////////////////////////////////////////
//                    РАБОТА С ПОРТАМИ                          //
//////////////////////////////////////////////////////////////////
;SET BIT with stack
	.MACRO	SETBM 
	.if @0 < 0x20
	SBI	@0,@1
	.else
		.if @0<0x40
	PUSH	R17
	IN	R17,@1
	ORI	R17,1<<@1
	OUT	@0,R17
	POP	R17
		.else
	PUSH	R17
	LDS	R17,@1
	ORI	R17,1<<@1
	STS	@0,R17
	POP	R17
		.endif
	.endif
	.ENDM
 
;SET BIT with REG
	.MACRO	SETB
	.if @0 < 0x20			; Low IO
	SBI	@0,@1
	.else
		.if @0<0x40		; High IO
	IN	@2,@0
	ORI	@2,1<<@1
	OUT	@0,@2
		.else			; Memory
	LDS	@2,@0
	ORI	@2,1<<@1
	STS	@0,@2
		.endif
	.endif
	.ENDM
;.............................................................
;Clear BIT with REG
	.MACRO	CLRB
	.if @0 < 0x20			; Low IO
	CBI	@0,@1
	.else
		.if @0<0x40		; High IO
	IN	@2,@0
	ANDI	@2,~(1<<@1)
	OUT	@0,@2
		.else			; Memory
	LDS	@2,@0
	ANDI	@2,~(1<<@1)
	STS	@0,@2
		.endif
	.endif
	.ENDM
 
;Clear BIT with STACK
	.MACRO	CLRBM 
	.if @0 < 0x20
	CBI	@0,@1
	.else
		.if @0<0x40
	PUSH	R17
	IN	R17,@1
	ANDI	R17,~(1<<@1)
	OUT	@0,R17
	POP	R17
		.else
	PUSH	R17
	LDS	R17,@1
	ANDI	R17,~(1<<@1)
	STS	@0,R17
	POP	R17
		.endif
	.endif
	.ENDM
;.............................................................
 
	.MACRO	INVB
	.if	@0 < 0x40
	IN	@2,@0
	LDI	@3,1<<@1
	EOR	@3,@2
	OUT	@0,@3
	.else
	LDS	@2,@0
	LDI	@3,1<<@1
	EOR	@2,@3
	STS	@0,@2
	.endif
	.ENDM
 
	.MACRO	INVBM
	.if	@0 < 0x40
	PUSH	R16
	PUSH	R17
	IN	R16,@0
	LDI	R17,1<<@1
	EOR	R17,R16
	OUT	@0,R17
	POP	R17
	POP	R16
	.else
	PUSH	R16
	PUSH	R17
	LDS	R16,@0
	LDI	R17,1<<@1
	EOR	R17,R16
	STS	@0,R17
	POP	R17
	POP	R16
	.endif
	.ENDM
 //===============================================================================

 .MACRO PUSHF
		PUSH	R16
		IN	R16,SREG
		PUSH	R16
.ENDM
 
 
 .MACRO POPF
		POP	R16
		OUT	SREG,R16
		POP	R16
.ENDM


